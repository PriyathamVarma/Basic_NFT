# ERC-721 Smart contract Information

This article explains about the ERC-721 smart contracts and various functions associated with it.

## Most important functions

- Minting
- Burning
- Transfer


### Minting

Minting function helps in minting/creating the NFTs. For this we will be using openzeppelin standards. In the safemint method we need to give two parameters 
--> address of the person minting and token ID which is a counter of all NFT minted. So this basically creates an array of tokenIDS which are 
indexes associated with wallet addresses. Now, in setTokenURI we need to pass two parameters --> tokenID which will be helpful in referencing the addresses and uri of the 
token which is nothing but a link of the asset.

The function will be public because the function will be accessible to other users. onlyOwner modifier is used for the function which is imported from the Ownable.sol library. This helps in owner or the address that deployed this contract can only mint the NFTs.

```
    function safeMint(address to, string memory uri) public onlyOwner {
    // tokenID is generated by counter library which automatically tracks the number
        uint256 tokenId = _tokenIdCounter.current();
    // Increment everytime the NFT is minted. Its important to note that NFT index starts with 0   
        _tokenIdCounter.increment();
        
    // _safeMint method with tokenID and to(wallet address) as arguments    
        _safeMint(to, tokenId);
    // _setTokenURI method with tokenID and uri(possibly IPFS CID) as arguments     
        _setTokenURI(tokenId, uri);
    }

```

For anyone to mint the NFT take down the onlyOwner modifier for the safeMint function.

```
    function safeMint(address to, string memory uri) public  {
        // You code goes in here       
    }

```
Go to [open zeppelien docs](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-_safeMint-address-uint256-) for understanding what safe mint does.


# Full smart contract
```
// SPDX-License-Identifier: MIT
// The solidity versioning
pragma solidity ^0.8.4;
//0x1ea800Fc74BBCAF6E9D9DCd83Dfacc3Bb8b576c8

// Imports for implementing ERC721 standards
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract VCollections is ERC721, ERC721Enumerable, ERC721URIStorage {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    //variables
    uint256 MAX_SUPPLY = 100;


    constructor() ERC721("VCollections", "VCL") {}

    function safeMint(address to, string memory uri) public {
        uint256 tokenId = _tokenIdCounter.current();
        require(tokenId <= MAX_SUPPLY, "Over the Limit");
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    // The following functions are overrides required by Solidity because we are using interfaces.

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _burn(uint256 tokenId) internal override(ERC721,ERC721URIStorage){
        super._burn(tokenId);
    }
}

```
